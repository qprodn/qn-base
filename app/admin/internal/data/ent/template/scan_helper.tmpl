{{/* The line below tells Intellij/GoLand to enable the autocompletion based *gen.Type type. */}}
{{/* gotype: entgo.io/ent/entc/gen.Type */}}


{{ define "scan_helper" }}

{{ template "header" $ }}

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"reflect"
	"strings"

	entsql "entgo.io/ent/dialect/sql"
)

var (
	// ErrNotPointer 当传入的值不是指针时返回
	ErrNotPointer = errors.New("value必须是指针类型")
	// ErrMultiColumnToBasic 当尝试将多列结果映射到基本类型时返回
	ErrMultiColumnToBasic = errors.New("多列查询结果不能映射到基本类型")
	// ErrExecuteQuery 执行查询失败时返回
	ErrExecuteQuery = errors.New("执行查询失败")
	// ErrGetColumns 获取列信息失败时返回
	ErrGetColumns = errors.New("获取列信息失败")
	// ErrScanSingleValue 扫描单列值失败时返回
	ErrScanSingleValue = errors.New("扫描单列值失败")
	// ErrMultiColumnToBasicSlice 多列查询结果不能映射到基本类型切片时返回
	ErrMultiColumnToBasicSlice = errors.New("多列查询结果不能映射到基本类型切片")
	// ErrFieldNotSettable 字段不可设置时返回
	ErrFieldNotSettable = errors.New("字段不可设置")
)

// QueryScan 执行SQL查询并将结果映射到value中
// ctx: 上下文
// value: 目标值，可以是以下类型之一：
//   - 指向结构体的指针：用于单行多列结果
//   - 指向结构体切片的指针：用于多行多列结果
//   - 指向基本类型的指针：用于单行单列结果
//   - 指向基本类型切片的指针：用于多行单列结果
//
// query: SQL查询语句
// args: 查询参数
func (db *Database) QueryScan(ctx context.Context, value interface{}, query string, args ...interface{}) error {
	// 检查value是否为指针
	v := reflect.ValueOf(value)
	if v.Kind() != reflect.Ptr {
		return ErrNotPointer
	}

	// 获取指针指向的值
	v = v.Elem()

	// 执行查询
	rows, err := db.Query(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("%w: %v", ErrExecuteQuery, err)
	}
	defer rows.Close()

	// 获取列信息
	columns, err := rows.Columns()
	if err != nil {
		return fmt.Errorf("%w: %v", ErrGetColumns, err)
	}

	// 检查是否为单列查询
	isSingleColumn := len(columns) == 1

	// 根据value类型选择不同的处理方法
	switch v.Kind() {
	case reflect.Struct:
		return scanSingleStruct(rows, columns, v)
	case reflect.Slice:
		return scanSlice(rows, columns, v, isSingleColumn)
	default:
		// 处理基本类型（非结构体、非切片）
		if !isSingleColumn {
			return fmt.Errorf("%w，列数: %d", ErrMultiColumnToBasic, len(columns))
		}
		return scanSingleValue(rows, value)
	}
}

// scanSingleStruct 扫描单个结构体
func scanSingleStruct(rows *entsql.Rows, columns []string, v reflect.Value) error {
	if !rows.Next() {
		return sql.ErrNoRows
	}
	return scanRowToStruct(rows, columns, v)
}

// scanSingleValue 扫描单个基本类型值
func scanSingleValue(rows *entsql.Rows, value interface{}) error {
	if !rows.Next() {
		return sql.ErrNoRows
	}

	// 直接扫描到value
	if err := rows.Scan(value); err != nil {
		return fmt.Errorf("%w: %v", ErrScanSingleValue, err)
	}

	return nil
}

// scanSlice 扫描切片类型
func scanSlice(rows *entsql.Rows, columns []string, v reflect.Value, isSingleColumn bool) error {
	sliceType := v.Type()
	elemType := sliceType.Elem()

	// 预分配切片容量以提高性能
	capacity := 0
	if rows, ok := rows.ColumnScanner.(*sql.Rows); ok {
		if n, err := rows.ColumnTypes(); err == nil {
			capacity = len(n)
		}
	}

	if capacity > 0 {
		v.Grow(capacity)
	}

	// 检查切片元素类型
	if elemType.Kind() == reflect.Struct {
		// 结构体切片
		return scanStructSlice(rows, columns, v, elemType)
	} else if isSingleColumn {
		// 基本类型切片（单列查询）
		return scanBasicSlice(rows, v, elemType)
	}

	return fmt.Errorf("%w，列数: %d", ErrMultiColumnToBasicSlice, len(columns))
}

// scanStructSlice 扫描结构体切片
func scanStructSlice(rows *entsql.Rows, columns []string, v reflect.Value, elemType reflect.Type) error {
	for rows.Next() {
		// 创建新的结构体实例
		newElem := reflect.New(elemType).Elem()

		// 扫描到结构体
		if err := scanRowToStruct(rows, columns, newElem); err != nil {
			return err
		}

		// 将结构体添加到切片
		v.Set(reflect.Append(v, newElem))
	}

	// 检查遍历过程中是否有错误
	return rows.Err()
}

// scanBasicSlice 扫描基本类型切片
func scanBasicSlice(rows *entsql.Rows, v reflect.Value, elemType reflect.Type) error {
	for rows.Next() {
		// 创建新的元素实例
		newElem := reflect.New(elemType).Elem()

		// 创建扫描目标
		scanTarget := newElem.Addr().Interface()

		// 执行扫描
		if err := rows.Scan(scanTarget); err != nil {
			return fmt.Errorf("%w: %v", ErrScanSingleValue, err)
		}

		// 将元素添加到切片
		v.Set(reflect.Append(v, newElem))
	}

	// 检查遍历过程中是否有错误
	return rows.Err()
}

// scanRowToStruct 将当前行扫描到结构体中
func scanRowToStruct(rows *entsql.Rows, columns []string, v reflect.Value) error {
	// 创建扫描目标
	scanTargets := make([]interface{}, len(columns))

	// 获取结构体类型
	t := v.Type()

	// 构建字段映射（支持结构体标签和不区分大小写）
	fieldMap := buildFieldMap(t)

	// 为每一列创建扫描目标
	for i, colName := range columns {
		// 查找匹配的字段
		fieldIndex, ok := fieldMap[strings.ToLower(colName)]
		if !ok {
			// 如果找不到匹配的字段，使用占位符
			var placeholder interface{}
			scanTargets[i] = &placeholder
			continue
		}

		// 获取字段
		field := v.Field(fieldIndex)

		// 检查字段是否可设置
		if !field.CanSet() {
			return fmt.Errorf("%w: %s", ErrFieldNotSettable, colName)
		}

		// 将字段地址作为扫描目标
		scanTargets[i] = field.Addr().Interface()
	}

	// 执行扫描
	return rows.Scan(scanTargets...)
}

// buildFieldMap 构建字段名到索引的映射
// 支持结构体标签和不区分大小写的字段名
func buildFieldMap(t reflect.Type) map[string]int {
	fieldMap := make(map[string]int)

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)

		// 添加字段名（不区分大小写）
		fieldMap[strings.ToLower(field.Name)] = i

		// 检查 db 标签
		if dbTag, ok := field.Tag.Lookup("scan"); ok && dbTag != "" {
			fieldMap[strings.ToLower(dbTag)] = i
		}
	}

	return fieldMap
}


{{ end }}